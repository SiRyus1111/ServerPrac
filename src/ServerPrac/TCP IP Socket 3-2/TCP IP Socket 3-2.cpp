#include <iostream>
#include <winsock2.h>
#include "Common.h"
#include <ws2tcpip.h>

/*
	바이트 정렬 = 메모리에 데이터를 저장할 때의 배치 순서.
	낮은 메모리 주소부터 높은 메모리 주소 순서대로 배치할 수도 있고,
	높은 메모리 주소에서 낮은 메모리 주소 순서대로 배치할 수도 있다..
	리틀 엔디언(Little Endian) : 낮은 메모리 주소에 더 큰 단위의 바이트가 저장되는 방식
	빅 엔디언(Big Endian) : 높은 메모리 주소에 더 큰 단위의 바이트가 저장되는 방식

	시스템에서 사용하는 바이트 정렬은 CPU와 운영체제에 따라 다르기 때문에
	서로 다른 시스템 간의 데이터를 교환할 때는 이걸 고려해야한다..

	왜 고려해야 하냐면,
	한 쪽에서 데이터를 리틀 엔디언 방식으로 파일에 저장하거나 네트워크로 전송했는데,
	다른 쪽에서 그 데이터를 빅 엔디언 방식으로 읽어서 해성하면,
	아예 다른 의미의 데이터로 인식되는 문제가 생긴다..

	막 IP 헤더의 IP 주소의 바이트 정렬을 약속하지 않으면 IP 주소가 엉뚱하게 해석될 수 있다..
	막 TCP/UDP 헤더의 포트 번호의 바이트 정렬을 약속하지 않으면 포트 번호가 엉뚱하게 해석되서 데이터가 잘못된 프로세스에 전달될 수 있다..
	방금 것들은 헤더지만, 만약 데이터(페이로드)의 바이트 정렬을 약속하지 않으면 데이터 해석이 엉뚱하게 될 수 있다..

	그래서 클라이언트와 서버가 통신하는 경우에는 빅/리틀 엔디언 중 하나로 바이트 정렬 방식을 통일해야 한다.

	응용 프로그램들이 바이트 정렬 방식을 편리하게 바꿀 수 있도록 윈속에서는 다음과 같은 함수를 제공한다.
	hton*() : 호스트 바이트 정렬로 저장된 값을 받아 네트워크 바이트 정렬로 반환
	ntoh*() : 네트워크 바이트 정렬로 저장된 값을 받아 호스트 바이트 정렬로 반환
	
	즉, 호스트에서 네트워크로 데이터를 보낼 때는 hton*() 함수를 사용해서 네트워크 바이트 정렬로 변환하고,
	네트워크에서 호스트로 데이터를 받을 때는 ntoh*() 함수를 사용해서 호스트 바이트 정렬로 변환한다.
	그리고 *의 자리는 s또는 l이 들어갈 수 있는데,
	s는 16비트 값을,
	l은 32비트 값을 입력으로 받는다.

	뭐 이정도. 이론은 이정도면 충분한 것 같다.

	TCP/IP에서 사용하는 소켓 주소 구조체인 sockaddr_in / sockaddr_in6 구조체는
	sockaddr_in의 멤버들 :
		sin_family(주소 체계) = 호스트 바이트 정렬
		sin_port(포트 번호) = 네트워크 바이트 정렬
		sin_addr(주소) = 네트워크 바이트 정렬
		sin_zero(패딩) = 호스트 바이트 정렬
	을 사용하고,
	sockaddr_in6의 멤버들 :
		sin6_family(주소 체계) = 호스트 바이트 정렬
		sin6_port(포트 번호) = 네트워크 바이트 정렬
		sin6_flowinfo(플로우 정보) = 네트워크 바이트 정렬
		sin6_addr(주소) = 네트워크 바이트 정렬
		sin6_scope_id(스코프 ID) = 호스트 바이트 정렬
	을 사용한다.

	실습에서는, 어떻게 호스트 바이트가 네트워크 바이트로 변환되는지,
	어떻게 네트워크 바이트가 호스트 바이트로 변환되는지를 실습해볼 생각이다.
*/
int main() {

	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
		std::cout << "[Error] 윈속 초기화 실패\n";
		return 1;
	}

	std::cout << "[Notice] 윈속 초기화 성공\n";

	unsigned short host4 = 0x1234;
	unsigned long host6 = 0x12345678;

	unsigned short net4 = htons(host4);
	unsigned long net6 = htonl(host6);

	std::cout << std::hex; // 16진수로 출력
	std::cout << std::showbase; // 16진수 접두사 0x 출력
	std::cout << "[Host to Network] 호스트 바이트 정렬 -> 네트워크 바이트 정렬\n";
	std::cout << "호스트 바이트 -> 네트워크 바이트 : " << host4 << " -> " << htons(host4) << "\n";
	std::cout << "호스트 바이트 -> 네트워크 바이트 : " << host6 << " -> " << htonl(host6) << "\n";

	std::cout << "[Network to Host] 네트워크 바이트 정렬 -> 호스트 바이트 정렬\n";
	std::cout << "네트워크 바이트 -> 호스트 바이트 : " << net4 << " -> " << ntohs(net4) << "\n";
	std::cout << "네트워크 바이트 -> 호스트 바이트 : " << net6 << " -> " << ntohl(net6) << "\n";

	return 0;
}